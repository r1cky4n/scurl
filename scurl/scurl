#!/usr/bin/python

#=======================================================================================================================
#
# CS255 Project 2 - SCURL
#
# Author:   Rick Yan <my259@stanford.edu>
#
#=======================================================================================================================



#=======================================================================================================================
# IMPORTS
#=======================================================================================================================
import OpenSSL
from OpenSSL import SSL

import socket


import argparse
from urlparse import urlparse
import sys
import time

#=======================================================================================================================
# Defines
#=======================================================================================================================

# Enumeration between different protocol choices -> TLS v1.0-1.2, SSLV3
#
def enum(**enums):
    return type('Enum', (), enums)
t_protocol = enum(tls_v1p0=0, tls_v1p1=1, tls_v1p2=2, ssl_v3=3)


# FIXME - for OSX, need to change on CORN
def_ca_file = '/etc/ssl/cert.pem' 
def_ca_path = '/etc/ssl/'

# HTTP Request Ending 
#
CRLF = '\r\n\r\n'

#=======================================================================================================================
# Internal Functions
#=======================================================================================================================


# Checks url for correctness
#
# Input URL from user can be either in number-and-dots notation, or text notation, this function should convert
# URL to number-and-dots notation to be properly used.
#
# URL input is a string
#
# Additional Checks for Correctness
#   reject URLS without https scheme
#   reject invalid addresses
#
#
def _check_and_format_url( url ):


    # URL Parse to get Schema, hostname, port
    #
    o = urlparse(url)

    # Scheme Check
    #
    if o.scheme != 'https':
        sys.stderr.write("Invalid URL, not HTTPS Scheme, exiting...\n")
        exit(1)
        
    # check if address is proper - FIXME is hostname all we need?
    #
    ip_addr = ""
    try:
        ip_addr = socket.gethostbyname(o.hostname)
    except socket.error:
        sys.stderr.write("Invalid URL, address not proper, exiting...\n")
        exit(1)

    # assign port if defined
    #
    ip_port = 443;
    try:
        if o.port != None:
            ip_port = o.port
    except ValueError:
        sys.stderr.write("Invalid URL, port not proper, exiting...\n")
        exit(1)

    return (ip_addr, ip_port)


# Choose protocol, should just be prot input, otherwise default to tls 1.2
#
def _choose_protocol( args ):
    if args.prot == 0:
        return SSL.TLSv1_METHOD
    elif args.prot == 1:
        return SSL.TLSv1_1_METHOD
    elif args.prot == 2:
        return SSL.TLSv1_2_METHOD
    elif args.prot == 3:
        return SSL.SSLv3_METHOD
    else:
        #return SSL.TLSv1_2_METHOD 
        return SSL.TLSv1_METHOD #FIXME - make it 1.2 default, for now it keep 1.0 so we can develop off of corn


# Sets up Context, Returns Context
# FIXME - input parameters
#
def _get_context( protocol ):
    context = SSL.Context(protocol)

    # FIXME - check options
    #
    context.set_options(SSL.OP_NO_SSLv2) # Don't accept SSLv2

    # VERIFY_NONE - When the SSL_CTX object is being used in client mode, any certificate received from the server will 
    #               be verified, but failure will not terminate the handshake.   
    # 
    # VERIFY_PEER - When the SSL_CTX object is being used in client mode, if the server sends a certificate, it will be 
    #               verified. If the verification fails, the handshake will be terminated immediately. The only time that 
    #               a server would not send a certificate is when an anonymous cipher is in use. Anonymous ciphers are 
    #               disabled by default. Any other flags combined with this one in client mode are ignored.
    #
    # We are using context in client mode, VERIFY_PEER is the right option
    #
    context.set_verify(SSL.VERIFY_PEER, _verify)

    context.load_verify_locations('/etc/ssl/cert.pem', '/etc/ssl/')

    # add input cert if cacert exists - FIXME
    # FIXME - CRL File 

    return context


# Sets up SSL Connection, Does Handshake, Returns SSL Socket
#
def _ssl_connect( context, ip_addr, port ):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    ssl_sock = SSL.Connection(context, sock)
    ssl_sock.connect((ip_addr, port))  # 443 is default https port
    
    try:
        ssl_sock.do_handshake()
    except Exception as e:
        sys.stderr.write("SSL do_handshake failed: "+str(e)+"\n")
        exit(1)
    
    return ssl_sock

# Close the SSL Socket
#
def _ssl_close( ssl_sock ):
    ssl_sock.close()


# Get the Certificate from the Connected Server
#
def _get_cert( ssl_sock ):
    cert = ssl_sock.get_peer_certificate()
    common_name = cert.get_subject().commonName.decode()

    print cert.get_subject().get_components()

    return cert

#=======================================================================================================================
# Certificate Verification Function
#=======================================================================================================================


def _verify(conn, cert, errno, depth, result):
    #print "ssl callback"

    #print conn
    #print 
    #print cert
    #print
    #print errno
    #print 
    #print depth
    #print
    #print result

    #print "-------------------------------"


    if depth == 0 and (errno == 9 or errno == 10):
        return False # or raise Exception("Certificate not yet valid or expired")
    return True


#=======================================================================================================================
# HTTP GET Request
#=======================================================================================================================

# Continuously call receive until all the data is parsed
#
def recv_with_timeout(ssl_sock,timeout=2):
    # make socket non blocking
    # 
    ssl_sock.setblocking(0)
     
    # total data partwise in an array
    #
    total_data = []
    data=''
     
    # beginning time
    begin = time.time()
    while True:
        # if you got some data, then break after timeout
        #
        if total_data and ((time.time()-begin) > timeout):
            break
         
        # if you got no data at all, wait a little longer, twice the timeout
        #
        elif (time.time()-begin) > timeout*2:
            print 'error!!'
            break
         
        # recv something
        #
        try:
            data = ssl_sock.recv(8192)
            if data:
                total_data.append(data)
                
                # change the beginning time for measurement
                #
                begin=time.time()
            else:
                # sleep for some time to indicate a gap
                #
                time.sleep(0.1)
        except:
            pass
     
    # join all parts to make final string
    #
    return ''.join(total_data)



# Format the HTTP GET Request through SSL.CONNECTION
#
def _get_data( ssl_sock ):

    get_req = 'GET / HTTP/1.0' + CRLF

    ssl_sock.send(get_req)
    
    print "---------------------"
    print
   

    data = recv_with_timeout( ssl_sock )
    print data
   

    


#=======================================================================================================================
# Main and Argument Parse
#=======================================================================================================================

def main():
    descr = 'Secure CURL implementation for CS 255 Project 2: Rick Yan <my259@stanford.edu>'
    parser = argparse.ArgumentParser(description=descr)

    # ARGUMENTS
    # 
    # Note - url is setup as a list, but we only need to worry about a single 
    parser.add_argument('--tlsv1.0',           action="store_const", dest="prot", const=0, help='Use TLSv1.0 (SSL)')
    parser.add_argument('--tlsv1.1',           action="store_const", dest="prot", const=1, help='Use TLSv1.1 (SSL)')
    parser.add_argument('--tlsv1.2',           action="store_const", dest="prot", const=2, help='Use TLSv1.2 (SSL)')
    parser.add_argument('--sslv3', '-3',       action="store_const", dest="prot", const=3, help='Use SSLv3 (SSL)')
    parser.add_argument('--ciphers',                      help='SSL ciphers to use (SSL)')
    parser.add_argument('--crlfile',                      help='Get a CRL list in PEM format from the given file')
    parser.add_argument('--cacert',                       help='CA certificate to verify peer against (SSL)')
    parser.add_argument('--allow-stale-certs', dest="N",  help='Allow stale certificate less than N days old to be used')
    parser.add_argument('--pinnedcertificate',            help='Only send data to authenticated server, overrides --cacert and --crlfile')
    parser.add_argument('url',                 nargs="*", help='URL target')

    args = parser.parse_args()



    if (len(args.url) == 0):
        sys.stderr.write("Please Input a URL, use ./scurl --help for more information\n")
        exit(1)


    
    protocol    = _choose_protocol( args )
    (addr,port) = _check_and_format_url( args.url[0] )
    
    
    
    
    
    
    
    
    
    
    ctx         = _get_context( protocol )








    ssl_sock    = _ssl_connect( ctx, addr, port )
    cert        = _get_cert( ssl_sock )

    _get_data( ssl_sock )


    _ssl_close(ssl_sock)



if __name__ == '__main__':
    main()




